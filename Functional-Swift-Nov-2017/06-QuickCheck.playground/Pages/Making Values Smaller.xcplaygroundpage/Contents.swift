/*:
[Previous Page](@previous) • [Table of Contents](Table%20of%20Contents)

*/

/*:
## Making Values Smaller

*/

// --- (Hidden code block) ---
import Foundation

let numberOfIterations = 10
// ---------------------------
/*:
If we run our `check1` function on strings, we might receive a rather long
failure message:

``` swift-example
check1("Every string starts with Hello") { (s: String) in
    s.hasPrefix("Hello")
}
// "Every string starts with Hello" doesn't hold: "Very long string..."
```

Ideally, we'd like our failing input to be as short as possible. In general, the
smaller the counterexample, the easier it is to spot which piece of code is
causing the failure. In this example, the counterexample is still pretty easy to
understand, but this may not always be the case. Imagine a complicated condition
on arrays or dictionaries that fails for some unclear reason — diagnosing why a
test is failing is much easier with a minimal counterexample. In principle, the
user could try to trim the input that triggered the failure and attempt
rerunning the test — rather than place the burden on the user, however, we'll
automate this process.

To do so, we'll make an extra protocol called `Smaller`, which does only one
thing — it tries to shrink the counterexample:

*/

protocol Smaller {
    func smaller() -> Self?
}

/*:
Note that the return type of the `smaller` function is marked as optional. There
are cases when it isn't clear how to shrink test data any further. For example,
there's no way to shrink an empty array. In that case, we'll return `nil`.

In our instance, for integers, we just try to divide the integer by two until we
reach zero:

*/

extension Int: Smaller {
    func smaller() -> Int? {
        return self == 0 ? nil : self / 2
    }
}

/*:
We can now test our instance:

*/

100.smaller()

/*:
For strings, we just drop the first character (unless the string is empty):

*/

extension String: Smaller {
    func smaller() -> String? {
        return isEmpty ? nil : String(characters.dropFirst())
    }
}

/*:
To use the `Smaller` protocol in the `check` function, we'll need the ability to
shrink any test data generated by our `check` function. To do so, we'll redefine
our `Arbitrary` protocol to extend the `Smaller` protocol:

*/

protocol Arbitrary: Smaller {
    static func arbitrary() -> Self
}

/*:
### Repeatedly Shrinking

We can now redefine our `check` function to shrink any test data that triggers a
failure. To do this, we use the `iterate(while:initial:next:)` function, which
takes a condition and an initial value and repeatedly applies a function as long
as the condition holds. We define it recursively, but we could also implement it
using a `while` loop:

*/

func iterate<A>(while condition: (A) -> Bool, initial: A, next: (A) -> A?) -> A {
    guard let x = next(initial), condition(x) else {
        return initial
    }
    return iterate(while: condition, initial: x, next: next)
}

/*:
Using `iterate(while:initial:next)`, we can now repeatedly shrink
counterexamples we uncover during testing:

*/

func check2<A: Arbitrary>(_ message: String, _ property: (A) -> Bool) -> () {
    for _ in 0..<numberOfIterations {
        let value = A.arbitrary()
        guard property(value) else {
            let smallerValue = iterate(while: { !property($0) }, initial: value) {
                $0.smaller()
            }
            print("\"\(message)\" doesn't hold: \(smallerValue)")
            return
        }
    }
    print("\"\(message)\" passed \(numberOfIterations) tests.")
}

/*:
This function is doing quite a lot: generating random input values, checking
whether the values satisfy the `property` argument, and repeatedly shrinking a
counterexample once one is found. One advantage of defining the repeated
shrinking using `iterate(while:initial:next)`, rather than a separate while
loop, is that the control flow of this piece of code stays reasonably simple.

### Arbitrary Arrays

Currently, our `check2` function only supports `Int` and `String` values. While
we're free to define new extensions for other types, such as `Bool`, things get
more complicated when we want to generate arbitrary arrays. As a motivating
example, let's write a functional version of QuickSort:

*/

func qsort(_ input: [Int]) -> [Int] {
    var array = input
    if array.isEmpty { return [] }
    let pivot = array.removeFirst()
    let lesser = array.filter { $0 < pivot }
    let greater = array.filter { $0 >= pivot }
    let intermediate = qsort(lesser) + [pivot]
    return intermediate + qsort(greater)
}

/*:
> Note: unfortunately, the code above needs an intermediate variable because of
> a bug in Swift, as outlined here https://bugs.swift.org/browse/SR-1914.

We can also try to write a property to check our version of QuickSort against
the built-in `sort` function:

``` swift-example
check2("qsort should behave like sort") { (x: [Int]) in
    return qsort(x) == x.sorted()
} // Error
```

However, the compiler warns us that `[Int]` doesn't conform to the `Arbitrary`
protocol. Before we can implement `Arbitrary`, we first have to implement
`Smaller`. As a first step, we provide a simple definition that drops the last
element in the array:

*/

extension Array: Smaller {
    func smaller() -> [Element]? {
        guard !isEmpty else { return nil }
        return Array(dropLast())
    }
}

/*:
We can also write a function that generates an array of arbitrary length for any
type that conforms to the `Arbitrary` protocol:

*/

// --- (Hidden code block) ---
extension Int {
    static func arbitrary(in range: CountableRange<Int>) -> Int {
        let diff = range.upperBound - range.lowerBound
        return range.lowerBound + (Int.arbitrary() % diff)
    }
}
// ---------------------------
extension Array where Element: Arbitrary {
    static func arbitrary() -> [Element] {
        let randomLength = Int.arbitrary(in: 0..<50)
        return (0..<randomLength).map { _ in .arbitrary() }
    }
}

/*:
Now what we'd like to do is make `Array` itself conform to the `Arbitrary`
protocol. However, only arrays with elements that conform to `Arbitrary` as well
can themselves conform to `Arbitrary`. For example, in order to generate an
array of random numbers, we first need to make sure that we can generate random
numbers. Ideally, we'd write something like this, saying that the elements of an
array should also conform to the arbitrary protocol:

``` swift-example
extension Array: Arbitrary where Element: Arbitrary {
    static func arbitrary() -> [Element] {
        // ...
    }
}
```

Unfortunately, it's currently not yet possible to express this restriction as a
type constraint, making it impossible to write an extension that makes `Array`
conform to the `Arbitrary` protocol. Instead, we'll modify the `check2`
function.

The problem with the `check2<A>` function was that it required the type `A` to
be `Arbitrary`. We'll drop this requirement and instead require the necessary
functions, `smaller` and `arbitrary`, to be passed in as arguments.

We start by defining an auxiliary struct that contains the two functions we
need:

*/

struct ArbitraryInstance<T> {
    let arbitrary: () -> T
    let smaller: (T) -> T?
}

/*:
We can now write a helper function that takes an `ArbitraryInstance` struct as
an argument. The definition of `checkHelper` closely follows the `check2`
function we saw previously. The only difference between the two is where the
`arbitrary` and `smaller` functions are defined. In `check2`, these were
constraints on the generic type, `<A: Arbitrary>`; in `checkHelper`, they're
passed explicitly in the `ArbitraryInstance` struct:

*/

func checkHelper<A>(_ arbitraryInstance: ArbitraryInstance<A>,
    _ property: (A) -> Bool, _ message: String) -> ()
{
    for _ in 0..<numberOfIterations {
        let value = arbitraryInstance.arbitrary()
        guard property(value) else {
            let smallerValue = iterate(while: { !property($0) },
                initial: value, next: arbitraryInstance.smaller)
            print("\"\(message)\" doesn't hold: \(smallerValue)")
            return
        }
    }
    print("\"\(message)\" passed \(numberOfIterations) tests.")
}

/*:
This is a standard technique: instead of working with functions defined in a
protocol, we explicitly pass the required information as an argument. By doing
so, we have a bit more flexibility. We no longer rely on Swift to *infer* the
required information, but instead have complete control over this ourselves.

We can redefine our `check2` function to use the `checkHelper` function. If we
know that we have the desired `Arbitrary` definitions, we can wrap them in the
`ArbitraryInstance` struct and call `checkHelper`:

*/

func check<X: Arbitrary>(_ message: String, property: (X) -> Bool) -> () {
    let instance = ArbitraryInstance(arbitrary: X.arbitrary,
        smaller: { $0.smaller() })
    checkHelper(instance, property, message)
}

/*:
If we have a type for which we can't define the desired `Arbitrary` instance, as
is the case with arrays, we can overload the `check` function and construct the
desired `ArbitraryInstance` struct ourselves:

*/

func check<X: Arbitrary>(_ message: String, _ property: ([X]) -> Bool) -> () {
    let instance = ArbitraryInstance(arbitrary: Array.arbitrary,
        smaller: { (x: [X]) in x.smaller() })
    checkHelper(instance, property, message)
}

/*:
Now, we can finally run `check` to verify our QuickSort implementation. Lots of
random arrays will be generated and passed to our test:

*/

// --- (Hidden code block) ---
extension Int: Arbitrary {
    static func arbitrary() -> Int {
        return Int(arc4random())
    }
}
// ---------------------------
check("qsort should behave like sort") { (x: [Int]) in
    return qsort(x) == x.sorted()
}

/*:
### Using QuickCheck

Somewhat counterintuitively, there's strong evidence to suggest that testing
technology influences the design of your code. People who rely on *test-driven
design* use tests not only to verify that their code is correct. Instead, they
also report that by writing your code in a test-driven fashion, the design of
the code gets simpler. This makes sense — if it's easy to write a test for a
class without having a complicated setup procedure, it means the class is nicely
decoupled.

For QuickCheck, the same rules apply. It'll often not be easy to take existing
code and add QuickCheck tests as an afterthought, particularly when you have an
existing object-oriented architecture that relies heavily on other classes or
makes use of mutable state. However, if you start by doing test-driven
development using QuickCheck, you'll see that it strongly influences the design
of your code.

QuickCheck forces you to think of the abstract properties that your functions
must satisfy and allows you to give a high-level specification. A unit test can
assert that `3 + 0` is equal to `0 + 3`; a QuickCheck property states more
generally that addition is a commutative operation. By thinking about a
high-level QuickCheck specification first, your code is more likely to be biased
toward modularity and *referential transparency* (which we'll cover in the next
chapter). When it comes to stateful functions or APIs, QuickCheck doesn't work
as well. As a result, writing your tests up front with QuickCheck will help keep
your code clean.

### Next Steps

This library is far from complete, but it's already quite useful. That said,
there are a couple of obvious things that could be improved upon:

  - The shrinking is naive. For example, in the case of arrays, we currently
    remove the first element of the array. However, we might also choose to
    remove a different element, or make the elements of the array smaller (or do
    all of that). The current implementation returns an optional shrunken value,
    whereas we might want to generate a list of values. In a later chapter,
    we'll see how to generate a lazy list of results, and we could use that same
    technique here.

  - The `Arbitrary` instances are quite simple. For different data types, we
    might want to have more complicated arbitrary instances. For example, when
    generating arbitrary enum values, we could generate certain cases with
    different frequencies. We could also generate constrained values, such as
    sorted or non-empty arrays. When writing multiple `Arbitrary` instances,
    it's possible to define some helper functions that aid us in writing these
    instances.

  - Classify the generated test data: if we generate a lot of arrays of length
    one, we could classify this as a 'trivial' test case. The Haskell library
    has support for classification, so these ideas could be ported directly.

  - We might want better control of the size of the random input that's
    generated. In the Haskell version of QuickCheck, the `Arbitrary` protocol
    takes an additional size argument, limiting the size of the random input
    generated; the `check` function than starts testing 'small' values, which
    correspond to small and fast tests. As more and more tests pass, the `check`
    function increases the size to try and find larger, more complicated
    counterexamples.

  - We might also want to initialize the random generator with an explicit seed,
    and make it possible to replay the generation of test cases. This will make
    it easier to reproduce failing tests.

Obviously, that's not everything; there are many other small and large things
that could be improved upon to make this into a full library.

There are a number of libraries available for Swift that implement
property-based testing. One such library is
[SwiftCheck](https://github.com/typelift/SwiftCheck). For testing Objective-C
code, there's [Fox](https://github.com/jeffh/Fox).

*/

/*:
[Previous Page](@previous) • [Table of Contents](Table%20of%20Contents)

*/
