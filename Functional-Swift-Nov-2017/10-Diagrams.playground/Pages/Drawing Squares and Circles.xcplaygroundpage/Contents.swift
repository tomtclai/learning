/*:
[Previous Page](@previous) • [Table of Contents](Table%20of%20Contents) • [Next
Page](@next)

*/

/*:
## Drawing Squares and Circles

Imagine drawing the diagram in Figure {@fig:diagram1}. In Core Graphics, we
could achieve this drawing with the following commands:

![A simple diagram](artwork/example1.png){\#fig:diagram1}

*/

// --- (Hidden code block) ---
#if os(macOS)
import Cocoa 
typealias UIColor = NSColor
class UIImage { }
class UIGraphicsImageRendererContext {
   var currentImage: UIImage {
       return UIImage()
   }

   func fill(_ rect: CGRect) {
   }
   var cgContext: CGContext {
       return CGContext(data: nil, width: 800, height: 600, bitsPerComponent: 8, bytesPerRow: 800*8, space: CGColorSpaceCreateDeviceRGB(), bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue)!
      
   }
   
}
class UIGraphicsImageRenderer {
    init(bounds: CGRect) {
    }
    func image(actions: (UIGraphicsImageRendererContext) -> Void) -> UIImage {
        return UIImage()
    }
    
}
#else
import UIKit
#endif
// ---------------------------
let bounds = CGRect(origin: .zero, size: CGSize(width: 300, height: 200))
let renderer = UIGraphicsImageRenderer(bounds: bounds)
renderer.image { context in
    UIColor.blue.setFill()
    context.fill(CGRect(x: 0.0, y: 37.5, width: 75.0, height: 75.0))
    UIColor.red.setFill()
    context.fill(CGRect(x: 75.0, y: 0.0, width: 150.0, height: 150.0))
    UIColor.green.setFill()
    context.cgContext.fillEllipse(in:
        CGRect(x: 225.0, y: 37.5, width: 75.0, height: 75.0))
}

/*:
This is nice and short, but it's a bit difficult to maintain. For example, what
if we wanted to add an extra circle like in Figure {@fig:diagram2}?

![Adding an extra circle](artwork/example2.png){\#fig:diagram2}

We'd need to add the code for drawing a circle and also update the drawing code
to move some of the other objects to the right. In Core Graphics, we always
describe *how* to draw things. In this chapter, we'll build a library for
diagrams that allows us to express *what* we want to draw. For example, the
first diagram can be expressed like this:

``` swift-example
let blueSquare = square(side: 1).filled(.blue)
let redSquare = square(side: 2).filled(.red)
let greenCircle = circle(diameter: 1).filled(.green)
let example1 = blueSquare ||| redSquare ||| greenCircle
```

Adding the second circle is as simple as changing the last line of code:

``` swift-example
let cyanCircle = circle(diameter: 1).filled(.cyan)
let example2 = blueSquare ||| cyanCircle ||| redSquare ||| greenCircle
```

The code above first describes a blue square with a relative size of `1`. The
red square is twice as big (it has a relative size of `2`). We compose the
diagram by putting the squares and the circle next to each other with the `|||`
operator. Changing this diagram is very simple, and there's no need to worry
about calculating frames or moving things around. The examples describe *what*
should be drawn, not *how* it should be drawn.

In the chapter about thinking functionally, we've constructed regions by
composing simple functions. While it served us well to illustrate functional
programming concepts, this approach has one decisive drawback: we can't inspect
*how* a region has been constructed — we can only check whether or not a point
is included.

In this chapter we'll go one step further: instead of immediately executing the
drawing commands, we build an intermediate data structure that describes the
diagram. This is a very powerful technique; contrary to the regions example, it
allows us to inspect the data structure, modify it, and convert it into
different formats.

As a more complex example of a diagram generated by the same library, Figure
{@fig:diagram3} shows a bar graph:

![A bar graph](artwork/example3.png){\#fig:diagram3}

We can write a `barGraph` function that takes a list of names (the keys) and
values (the relative heights of the bars). For each value in the dictionary, we
draw a suitably sized rectangle. We then horizontally concatenate these
rectangles with the `hcat` method. Finally, we put the bars and the text below
each other using the `---` operator:

``` swift-example
func barGraph(_ input: [(String, Double)]) -> Diagram {
    let values: [CGFloat] = input.map { CGFloat($0.1) }
    let bars = values.normalized.map { x in
        return rect(width: 1, height: 3 * x).filled(.black).aligned(to: .bottom)
    }.hcat
    let labels = input.map { label, _ in
        return text(label, width: 1, height: 0.3).aligned(to: .top)
    }.hcat
    return bars --- labels
}

```

The `normalized` property used above simply normalizes all values so that the
largest one equals one.

*/

/*:
[Previous Page](@previous) • [Table of Contents](Table%20of%20Contents) • [Next
Page](@next)

*/
